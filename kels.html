<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Where in the world is Kels?</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      :root {
        color-scheme: light;
        --surface: rgba(255, 255, 255, 0.82);
        --text: #152033;
        --accent: #5a3fd4;
        --accent-soft: rgba(90, 63, 212, 0.16);
        --backdrop: radial-gradient(
            circle at 18% 20%,
            rgba(90, 63, 212, 0.24),
            transparent 58%
          ),
          radial-gradient(
            circle at 78% 8%,
            rgba(231, 109, 161, 0.2),
            transparent 55%
          ),
          linear-gradient(135deg, #f2f4fb 0%, #f9f0f3 45%, #fef8ee 100%);
        --status-sea: #c06c0d;
        --status-sea-bg: rgba(255, 180, 60, 0.18);
        --status-docked: #1f7d52;
        --status-docked-bg: rgba(58, 180, 122, 0.18);
        --status-unknown: #4f5363;
        --status-unknown-bg: rgba(124, 130, 155, 0.16);
        --pin-shadow: rgba(0, 113, 227, 0.32);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Manrope", "SF Pro Display", "Helvetica Neue", Arial,
          sans-serif;
        background: var(--backdrop);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.5rem;
        padding: 2rem 1.5rem 3rem;
        color: var(--text);
      }

      body.birthday-mode {
        background: linear-gradient(
          135deg,
          #fdf8ff 0%,
          #f9ecf5 50%,
          #fff7eb 100%
        );
        color: #4d213b;
      }

      body.christmas-mode {
        --surface: rgba(255, 255, 255, 0.9);
        --text: #12211c;
        --accent: #b91c1c;
        --accent-soft: rgba(185, 28, 28, 0.16);
        --backdrop: radial-gradient(
            circle at 22% 18%,
            rgba(185, 28, 28, 0.18),
            transparent 60%
          ),
          radial-gradient(
            circle at 78% 12%,
            rgba(22, 101, 52, 0.16),
            transparent 55%
          ),
          linear-gradient(135deg, #f3f7f5 0%, #edf4f0 45%, #f9eeec 100%);
        --status-sea: #166534;
        --status-sea-bg: rgba(22, 101, 52, 0.16);
        --status-docked: #b91c1c;
        --status-docked-bg: rgba(185, 28, 28, 0.16);
        --status-unknown: #0f172a;
        --status-unknown-bg: rgba(15, 23, 42, 0.12);
        --pin-shadow: rgba(15, 118, 110, 0.3);
        background: var(--backdrop);
        color: var(--text);
      }

      .countdown-banner {
        width: min(900px, 100%);
        background: var(--accent);
        color: white;
        border-radius: 999px;
        padding: 0.85rem 1.75rem;
        font-size: 1.05rem;
        font-weight: 600;
        text-align: center;
        box-shadow: 0 18px 40px rgba(0, 113, 227, 0.3);
      }

      .christmas-banner {
        width: min(900px, 100%);
        background: linear-gradient(135deg, #14532d, #166534);
        color: #fef2f2;
        border-radius: 999px;
        padding: 1.05rem 1.75rem;
        font-size: 1.35rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        text-align: center;
        box-shadow: 0 22px 55px rgba(14, 116, 65, 0.35);
        margin: 0;
      }

      .christmas-banner[hidden] {
        display: none;
      }

      .shell {
        width: min(900px, 100%);
        background: var(--surface);
        border-radius: 30px;
        box-shadow: 0 26px 70px rgba(27, 37, 68, 0.22);
        backdrop-filter: blur(26px) saturate(140%);
        border: 1px solid rgba(255, 255, 255, 0.58);
        padding: clamp(2.4rem, 4vw, 3rem);
        display: grid;
        gap: 2.4rem;
      }

      .birthday-shell {
        position: relative;
        width: min(900px, 100%);
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.92) 0%,
          rgba(255, 246, 251, 0.9) 60%,
          rgba(250, 239, 255, 0.88) 100%
        );
        border-radius: 36px;
        padding: clamp(3rem, 5vw, 4.75rem);
        text-align: center;
        box-shadow: 0 32px 82px rgba(145, 88, 188, 0.24);
        border: 1px solid rgba(235, 194, 255, 0.55);
        overflow: hidden;
      }

      .birthday-shell[hidden] {
        display: none;
      }

      .birthday-shell h1 {
        margin: 0 0 1rem;
        font-size: clamp(3.2rem, 8vw, 5rem);
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #8f3a9a;
        text-shadow: 0 14px 34px rgba(156, 70, 176, 0.38);
      }

      .birthday-lead {
        font-size: clamp(1.45rem, 4vw, 2.1rem);
        margin: 0 0 0.9rem;
        font-weight: 600;
        color: #6d2967;
      }

      .birthday-sub {
        font-size: clamp(1.2rem, 3vw, 1.55rem);
        margin: 0;
        color: #553350;
      }

      .shell.birthday-visible {
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(226, 198, 255, 0.7);
        box-shadow: 0 28px 72px rgba(143, 58, 154, 0.22);
      }

      body.christmas-mode main.shell {
        background: rgba(255, 255, 255, 0.86);
        border-radius: 32px;
        border: 1px solid rgba(15, 118, 110, 0.2);
        box-shadow: 0 32px 80px rgba(15, 118, 110, 0.28);
      }

      body.christmas-mode header h1 {
        color: #14532d;
      }

      .shell.birthday-visible header h1 {
        color: #6d2967;
      }

      .shell.birthday-visible .status-badge {
        background: rgba(255, 214, 229, 0.6);
        color: #c2255c;
      }

      header {
        text-align: center;
      }

      h1 {
        margin: 0;
        font-size: clamp(2.3rem, 4vw, 3.4rem);
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      .status {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        align-items: center;
        text-align: center;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.045em;
        text-transform: uppercase;
        padding: 0.45rem 1.15rem;
        border-radius: 999px;
        background: var(--accent-soft);
        color: var(--accent);
        transition: background 0.3s ease, color 0.3s ease;
      }

      .status-badge[data-state="sea"] {
        background: var(--status-sea-bg);
        color: var(--status-sea);
      }

      .status-badge[data-state="docked"] {
        background: var(--status-docked-bg);
        color: var(--status-docked);
      }

      .status-badge[data-state="unknown"] {
        background: var(--status-unknown-bg);
        color: var(--status-unknown);
      }

      .status p {
        margin: 0;
        font-size: 1.15rem;
        line-height: 1.5;
      }

      .status strong {
        font-size: 1.35rem;
        font-weight: 600;
        padding: 0.25rem 0.75rem;
        border-radius: 999px;
        background: var(--accent-soft);
        color: var(--accent);
      }

      #map {
        width: 100%;
        height: clamp(360px, 55vh, 520px);
        border-radius: 22px;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
      }

      .weather-section {
        background: var(--accent-soft);
        border-radius: 22px;
        padding: 1.75rem 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        border: 1px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 8px 24px rgba(27, 37, 68, 0.1);
      }

      .time-section {
        background: rgba(255, 255, 255, 0.75);
        border-radius: 18px;
        padding: 1.4rem 1.75rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: 0 10px 26px rgba(27, 37, 68, 0.12);
      }

      .time-header {
        display: flex;
        align-items: center;
        gap: 0.85rem;
        flex: 1;
      }

      .time-icon {
        font-size: 1.5rem;
      }

      .time-text {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .time-section h2 {
        margin: 0;
        font-size: 1.15rem;
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      .time-description {
        margin: 0;
        font-size: 0.98rem;
        color: rgba(21, 32, 51, 0.76);
      }

      .time-clock {
        font-weight: 800;
        font-size: 1.75rem;
        letter-spacing: 0.04em;
        background: rgba(90, 63, 212, 0.1);
        color: var(--accent);
        padding: 0.6rem 0.9rem;
        border-radius: 14px;
        box-shadow: inset 0 0 0 1px rgba(90, 63, 212, 0.2);
      }

      .weather-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.5rem;
      }

      .weather-icon {
        font-size: 1.75rem;
        line-height: 1;
      }

      .weather-section h2 {
        margin: 0;
        font-size: 1.35rem;
        font-weight: 700;
        color: var(--accent);
        letter-spacing: -0.01em;
      }

      .weather-content {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .weather-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1.5rem;
        flex-wrap: wrap;
      }

      .weather-temp {
        display: flex;
        align-items: baseline;
        gap: 0.25rem;
      }

      .weather-current {
        font-size: 3rem;
        font-weight: 700;
        color: var(--text);
        line-height: 1;
      }

      .weather-unit {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text);
        opacity: 0.7;
      }

      .weather-high-low {
        display: flex;
        gap: 1rem;
        font-size: 1.15rem;
        font-weight: 600;
        color: var(--text);
      }

      .weather-high-low span {
        padding: 0.4rem 0.9rem;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 12px;
        backdrop-filter: blur(8px);
      }

      .weather-conditions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        font-size: 1rem;
        color: var(--text);
      }

      .weather-condition-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 1rem;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.95rem;
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.5);
      }

      .weather-condition-badge.rain {
        background: rgba(59, 130, 246, 0.15);
        color: #2563eb;
        border-color: rgba(59, 130, 246, 0.3);
      }

      .weather-condition-badge.snow {
        background: rgba(147, 197, 253, 0.2);
        color: #1e40af;
        border-color: rgba(147, 197, 253, 0.3);
      }

      .weather-condition-badge.wind {
        background: rgba(251, 191, 36, 0.15);
        color: #d97706;
        border-color: rgba(251, 191, 36, 0.3);
      }

      #weather-loading {
        color: var(--text);
        opacity: 0.7;
        font-style: italic;
      }

      @media (max-width: 600px) {
        .weather-section {
          padding: 1.5rem 1.5rem;
        }

        .weather-current {
          font-size: 2.5rem;
        }

        .weather-unit {
          font-size: 1.25rem;
        }

        .weather-high-low {
          font-size: 1rem;
        }

        .weather-section h2 {
          font-size: 1.2rem;
        }
      }

      footer {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.6rem;
        font-size: 1.1rem;
        flex-wrap: wrap;
      }

      .sparkle {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: linear-gradient(
          135deg,
          rgba(255, 214, 10, 0.9),
          rgba(255, 149, 0, 0.7)
        );
        box-shadow: 0 0 20px rgba(255, 214, 10, 0.7);
      }

      body.christmas-mode .sparkle {
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.8),
          rgba(239, 68, 68, 0.75)
        );
        box-shadow: 0 0 22px rgba(239, 68, 68, 0.65);
      }

      .language-toggle {
        position: fixed;
        top: 1.5rem;
        right: 1.5rem;
        z-index: 1000;
        background: var(--surface);
        border: 1px solid rgba(255, 255, 255, 0.58);
        border-radius: 999px;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--accent);
        cursor: pointer;
        box-shadow: 0 8px 24px rgba(27, 37, 68, 0.15);
        backdrop-filter: blur(26px) saturate(140%);
        transition: all 0.3s ease;
        font-family: "Manrope", "SF Pro Display", "Helvetica Neue", Arial,
          sans-serif;
      }

      .language-toggle:hover {
        background: var(--accent-soft);
        transform: translateY(-2px);
        box-shadow: 0 12px 32px rgba(27, 37, 68, 0.2);
      }

      @media (max-width: 600px) {
        body {
          padding: 2rem 1rem;
        }

        .countdown-banner {
          font-size: 0.95rem;
          padding: 0.75rem 1.25rem;
          margin-top: 3.5rem;
        }

        .shell {
          padding: 2rem;
          gap: 1.75rem;
        }

        .status p {
          font-size: 1.05rem;
        }

        .language-toggle {
          top: 0.5rem;
          right: 0.5rem;
          padding: 0.35rem 0.75rem;
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <button
      id="language-toggle"
      class="language-toggle"
      aria-label="Switch language"
    >
      Dansk
    </button>
    <div id="christmas-banner" class="christmas-banner" hidden>
      Merry Christmas!
    </div>
    <section class="birthday-shell" id="birthday-shell" hidden>
      <div class="birthday-content">
        <h1>HAPPY BIRTHDAY KELS!</h1>
        <p class="birthday-lead">Today‚Äôs forecast: a perfect day at sea</p>
        ca
      </div>
    </section>
    <div class="countdown-banner" id="countdown-banner">
      Loading days until Kels is home...
    </div>
    <main class="shell">
      <header>
        <h1>Where in the world is Kels?</h1>
      </header>

      <section class="status" aria-live="polite">
        <div class="sparkle" aria-hidden="true"></div>
        <span
          id="ship-status"
          class="status-badge"
          role="status"
          data-state="unknown"
          >Loading status...</span
        >
        <p id="location-status">Loading Kels' current adventure...</p>
        <strong id="location-label"></strong>
      </section>

      <section class="time-section" aria-live="polite">
        <div class="time-header">
          <span class="time-icon" aria-hidden="true">‚è∞</span>
          <div class="time-text">
            <h2 id="time-title">Ship's local time</h2>
            <p id="time-description" class="time-description">
              Loading ship's local time...
            </p>
          </div>
        </div>
        <div id="time-clock" class="time-clock">--:--</div>
      </section>

      <div
        id="map"
        role="img"
        aria-label="Map showing Kels' current location"
      ></div>

      <section class="weather-section" id="weather-section" aria-live="polite">
        <div class="weather-header">
          <span class="weather-icon">üå§Ô∏è</span>
          <h2 id="weather-title">Weather at Ship Location</h2>
        </div>
        <div class="weather-content">
          <div class="weather-main">
            <div class="weather-temp">
              <span id="weather-current" class="weather-current">--</span>
              <span class="weather-unit">¬∞F</span>
            </div>
            <div class="weather-high-low">
              <span id="weather-high">H: --</span>
              <span id="weather-low">L: --</span>
            </div>
          </div>
          <div class="weather-conditions" id="weather-conditions">
            <span id="weather-loading">Loading weather...</span>
          </div>
        </div>
      </section>

      <footer>
        <span>üèä‚Äç‚ôÄÔ∏è</span>
        <span id="tomorrow-status">Loading tomorrow's plan...</span>
      </footer>
    </main>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script>
      // Translation system
      const translations = {
        en: {
          pageTitle: "Where in the world is Kels?",
          christmasBanner: "Merry Christmas!",
          birthdayTitle: "HAPPY BIRTHDAY KELS!",
          birthdayLead: "Today's forecast: a perfect day at sea",
          countdownLoading: "Loading days until Kels is home...",
          countdownDays: (days) => `${days} days until Kels is home! üè°`,
          statusLoading: "Loading status...",
          statusAtSea: "Somewhere at sea",
          statusDocked: "Docked",
          statusUnknown: "Status unknown",
          locationLoading: "Loading Kels' current adventure...",
          tomorrowLoading: "Loading tomorrow's plan...",
          tomorrowPrefix: "Tomorrow: ",
          tomorrowAtSea: "At sea",
          tomorrowAtSeaBetween: (prev, next) =>
            `At sea between ${prev} and ${next}`,
          itineraryUnavailable: "Itinerary unavailable",
          couldNotDetermine:
            "We could not determine the current itinerary position.",
          trackingUpdate: "Tracking the latest voyage update.",
          liveUpdate: "Live update: ",
          currentlySailing: "Currently sailing the open ocean.",
          currentlySailingToward: (dest) => `Currently sailing toward ${dest}.`,
          currentlySailingEnRoute: (dest) =>
            `Currently sailing en route to ${dest}.`,
          currentlyAlongside: (port) => `Currently alongside ${port}.`,
          latestCoordinates: "Latest live coordinates received.",
          enRouteTo: (dest) => `En route to ${dest}`,
          sailingOcean: "Sailing the open ocean",
          dockedAt: (port) => `Docked at ${port}`,
          sailingBetween: (prev, next) =>
            `Sailing between ${prev} and ${next}.`,
          sailingOnward: (prev) => `Sailing onward from ${prev}.`,
          approaching: (next) => `Approaching ${next}.`,
          dockedNear: (label) => `Docked near ${label}.`,
          transitingCanal: "Transiting the Panama Canal.",
          crossingDateLine: "Crossing the International Date Line.",
          showingCached: "Showing cached location.",
          cachedCoordinates: "Cached coordinates",
          mapAriaLabel: "Map showing Kels' current location",
          weatherTitle: "Weather at Ship Location",
          weatherLoading: "Loading weather...",
          weatherError: "Unable to load weather",
          rain: "Rain",
          snow: "Snow",
          wind: "Windy",
          noConditions: "Clear conditions",
          timeTitle: "Ship's local time",
          timeLoading: "Loading ship's local time...",
          timeSubtitle: (timezone) => `Based on ship position (${timezone})`,
          timeSubtitleOffset: (offset) =>
            `Based on ship position (UTC${offset || "?"})`,
        },
        da: {
          pageTitle: "Hvor i verden er Kels?",
          christmasBanner: "Gl√¶delig jul!",
          birthdayTitle: "TILLYKKE MED F√òDSELSDAGEN KELS!",
          birthdayLead: "Dagens vejrudsigt: en perfekt dag til s√∏s",
          countdownLoading: "Indl√¶ser dage indtil Kels er hjemme...",
          countdownDays: (days) => `${days} dage indtil Kels er hjemme! üè°`,
          statusLoading: "Indl√¶ser status...",
          statusAtSea: "Et sted til s√∏s",
          statusDocked: "Fort√∏jet",
          statusUnknown: "Status ukendt",
          locationLoading: "Indl√¶ser Kels' nuv√¶rende eventyr...",
          tomorrowLoading: "Indl√¶ser i morgen plan...",
          tomorrowPrefix: "I morgen: ",
          tomorrowAtSea: "Til s√∏s",
          tomorrowAtSeaBetween: (prev, next) =>
            `Til s√∏s mellem ${prev} og ${next}`,
          itineraryUnavailable: "Rejseplan utilg√¶ngelig",
          couldNotDetermine:
            "Vi kunne ikke bestemme den nuv√¶rende rejseplan position.",
          trackingUpdate: "Sporer den seneste rejseopdatering.",
          liveUpdate: "Live opdatering: ",
          currentlySailing: "Sejler i √∏jeblikket p√• det √•bne hav.",
          currentlySailingToward: (dest) => `Sejler i √∏jeblikket mod ${dest}.`,
          currentlySailingEnRoute: (dest) =>
            `Sejler i √∏jeblikket p√• vej til ${dest}.`,
          currentlyAlongside: (port) => `I √∏jeblikket ved siden af ${port}.`,
          latestCoordinates: "Seneste live koordinater modtaget.",
          enRouteTo: (dest) => `P√• vej til ${dest}`,
          sailingOcean: "Sejler p√• det √•bne hav",
          dockedAt: (port) => `Fort√∏jet ved ${port}`,
          sailingBetween: (prev, next) => `Sejler mellem ${prev} og ${next}.`,
          sailingOnward: (prev) => `Sejler videre fra ${prev}.`,
          approaching: (next) => `N√¶rmer sig ${next}.`,
          dockedNear: (label) => `Fort√∏jet n√¶r ${label}.`,
          transitingCanal: "Passerer Panamakanalen.",
          crossingDateLine: "Krydser datolinjen.",
          showingCached: "Viser cached placering.",
          cachedCoordinates: "Cachede koordinater",
          mapAriaLabel: "Kort der viser Kels' nuv√¶rende placering",
          weatherTitle: "Vejr ved skibets placering",
          weatherLoading: "Indl√¶ser vejr...",
          weatherError: "Kunne ikke indl√¶se vejr",
          rain: "Regn",
          snow: "Sne",
          wind: "Bl√¶sende",
          noConditions: "Klart vejr",
          timeTitle: "Skibets lokale tid",
          timeLoading: "Indl√¶ser skibets lokale tid...",
          timeSubtitle: (timezone) => `Baseret p√• skibets position (${timezone})`,
          timeSubtitleOffset: (offset) =>
            `Baseret p√• skibets position (UTC${offset || "?"})`,
        },
      };

      let currentLanguage = "en";
      const languageToggle = document.getElementById("language-toggle");

      function translatePage(lang) {
        const previousLang = currentLanguage;
        currentLanguage = lang;
        const t = translations[lang];
        const tPrev = translations[previousLang];

        // Update button text
        languageToggle.textContent = lang === "en" ? "Dansk" : "English";

        // Update page title
        const titleEl = document.querySelector("header h1");
        if (titleEl) titleEl.textContent = t.pageTitle;

        // Update Christmas banner
        if (christmasBanner && !christmasBanner.hasAttribute("hidden")) {
          christmasBanner.textContent = t.christmasBanner;
        }

        // Update birthday content
        const birthdayTitleEl = document.querySelector("#birthday-shell h1");
        const birthdayLeadEl = document.querySelector(
          "#birthday-shell .birthday-lead"
        );
        if (birthdayTitleEl) birthdayTitleEl.textContent = t.birthdayTitle;
        if (birthdayLeadEl) birthdayLeadEl.textContent = t.birthdayLead;

        // Update countdown banner
        if (countdownBanner) {
          const currentText = countdownBanner.textContent;
          if (
            currentText.includes("Loading") ||
            currentText.includes("Indl√¶ser")
          ) {
            countdownBanner.textContent = t.countdownLoading;
          } else {
            const daysMatch = currentText.match(/(\d+)/);
            if (daysMatch) {
              countdownBanner.textContent = t.countdownDays(
                parseInt(daysMatch[1])
              );
            }
          }
        }

        // Update status badge
        const shipStatusEl = document.getElementById("ship-status");
        if (shipStatusEl) {
          const currentStatus = shipStatusEl.textContent;
          if (
            currentStatus.includes("Loading") ||
            currentStatus.includes("Indl√¶ser")
          ) {
            shipStatusEl.textContent = t.statusLoading;
          } else if (
            currentStatus.toLowerCase().includes("sea") ||
            currentStatus.toLowerCase().includes("s√∏s")
          ) {
            shipStatusEl.textContent = t.statusAtSea;
          } else if (
            currentStatus.toLowerCase().includes("dock") ||
            currentStatus.toLowerCase().includes("fort√∏j")
          ) {
            shipStatusEl.textContent = t.statusDocked;
          } else {
            shipStatusEl.textContent = t.statusUnknown;
          }
        }

        // Update location status
        const locationStatusEl = document.getElementById("location-status");
        if (locationStatusEl) {
          const currentText = locationStatusEl.textContent;
          if (
            currentText.includes("Loading") ||
            currentText.includes("Indl√¶ser")
          ) {
            locationStatusEl.textContent = t.locationLoading;
          } else {
            // Try to translate common patterns - check both English and Danish
            let translated = currentText;

            // English patterns
            if (currentText.includes("Sailing between")) {
              const match = currentText.match(
                /Sailing between (.+?) and (.+?)\./
              );
              if (match) {
                translated = t.sailingBetween(match[1], match[2]);
              }
            } else if (currentText.includes("Sejler mellem")) {
              const match = currentText.match(/Sejler mellem (.+?) og (.+?)\./);
              if (match) {
                translated = t.sailingBetween(match[1], match[2]);
              }
            } else if (currentText.includes("Sailing onward")) {
              const match = currentText.match(/Sailing onward from (.+?)\./);
              if (match) {
                translated = t.sailingOnward(match[1]);
              }
            } else if (currentText.includes("Sejler videre fra")) {
              const match = currentText.match(/Sejler videre fra (.+?)\./);
              if (match) {
                translated = t.sailingOnward(match[1]);
              }
            } else if (currentText.includes("Approaching")) {
              const match = currentText.match(/Approaching (.+?)\./);
              if (match) {
                translated = t.approaching(match[1]);
              }
            } else if (currentText.includes("N√¶rmer sig")) {
              const match = currentText.match(/N√¶rmer sig (.+?)\./);
              if (match) {
                translated = t.approaching(match[1]);
              }
            } else if (currentText.includes("Docked near")) {
              const match = currentText.match(/Docked near (.+?)\./);
              if (match) {
                translated = t.dockedNear(match[1]);
              }
            } else if (currentText.includes("Fort√∏jet n√¶r")) {
              const match = currentText.match(/Fort√∏jet n√¶r (.+?)\./);
              if (match) {
                translated = t.dockedNear(match[1]);
              }
            } else if (
              currentText.includes("Transiting the Panama Canal") ||
              currentText.includes("Passerer Panamakanalen")
            ) {
              translated = t.transitingCanal;
            } else if (
              currentText.includes("Crossing the International Date Line") ||
              currentText.includes("Krydser datolinjen")
            ) {
              translated = t.crossingDateLine;
            } else if (
              currentText.includes("sailing the open ocean") ||
              currentText.includes("Sejler i √∏jeblikket p√• det √•bne hav")
            ) {
              translated = t.currentlySailing;
            } else if (currentText.includes("Currently sailing toward")) {
              const match = currentText.match(
                /Currently sailing toward (.+?)\./
              );
              if (match) {
                translated = t.currentlySailingToward(match[1]);
              }
            } else if (currentText.includes("Sejler i √∏jeblikket mod")) {
              const match = currentText.match(
                /Sejler i √∏jeblikket mod (.+?)\./
              );
              if (match) {
                translated = t.currentlySailingToward(match[1]);
              }
            } else if (
              currentText.includes("Currently sailing en route") ||
              currentText.includes("Currently sailing en route to")
            ) {
              const match = currentText.match(
                /Currently sailing en route to (.+?)\./
              );
              if (match) {
                translated = t.currentlySailingEnRoute(match[1]);
              }
            } else if (currentText.includes("Sejler i √∏jeblikket p√• vej til")) {
              const match = currentText.match(
                /Sejler i √∏jeblikket p√• vej til (.+?)\./
              );
              if (match) {
                translated = t.currentlySailingEnRoute(match[1]);
              }
            } else if (currentText.includes("Currently alongside")) {
              const match = currentText.match(/Currently alongside (.+?)\./);
              if (match) {
                translated = t.currentlyAlongside(match[1]);
              }
            } else if (currentText.includes("I √∏jeblikket ved siden af")) {
              const match = currentText.match(
                /I √∏jeblikket ved siden af (.+?)\./
              );
              if (match) {
                translated = t.currentlyAlongside(match[1]);
              }
            } else if (
              currentText.includes("Latest live coordinates") ||
              currentText.includes("Seneste live koordinater")
            ) {
              translated = t.latestCoordinates;
            } else if (
              currentText.includes("Showing cached") ||
              currentText.includes("Viser cached")
            ) {
              translated = t.showingCached;
            } else if (
              currentText.includes("Live update:") ||
              currentText.includes("Live opdatering:")
            ) {
              const afterPrefix = currentText.replace(
                /^(Live update|Live opdatering):\s*/,
                ""
              );
              // Try to translate the content after the prefix
              let translatedAfter = afterPrefix;
              if (afterPrefix.includes("Sejler i √∏jeblikket p√• vej til")) {
                const match = afterPrefix.match(
                  /Sejler i √∏jeblikket p√• vej til (.+?)\./
                );
                if (match) {
                  translatedAfter = t.currentlySailingEnRoute(match[1]);
                }
              } else if (
                afterPrefix.includes("Currently sailing en route to")
              ) {
                const match = afterPrefix.match(
                  /Currently sailing en route to (.+?)\./
                );
                if (match) {
                  translatedAfter = t.currentlySailingEnRoute(match[1]);
                }
              } else if (afterPrefix.includes("Sejler i √∏jeblikket mod")) {
                const match = afterPrefix.match(
                  /Sejler i √∏jeblikket mod (.+?)\./
                );
                if (match) {
                  translatedAfter = t.currentlySailingToward(match[1]);
                }
              } else if (afterPrefix.includes("Currently sailing toward")) {
                const match = afterPrefix.match(
                  /Currently sailing toward (.+?)\./
                );
                if (match) {
                  translatedAfter = t.currentlySailingToward(match[1]);
                }
              } else if (
                afterPrefix.includes("Sejler i √∏jeblikket p√• det √•bne hav")
              ) {
                translatedAfter = t.currentlySailing;
              } else if (
                afterPrefix.includes("Currently sailing the open ocean")
              ) {
                translatedAfter = t.currentlySailing;
              } else if (afterPrefix.includes("I √∏jeblikket ved siden af")) {
                const match = afterPrefix.match(
                  /I √∏jeblikket ved siden af (.+?)\./
                );
                if (match) {
                  translatedAfter = t.currentlyAlongside(match[1]);
                }
              } else if (afterPrefix.includes("Currently alongside")) {
                const match = afterPrefix.match(/Currently alongside (.+?)\./);
                if (match) {
                  translatedAfter = t.currentlyAlongside(match[1]);
                }
              } else if (afterPrefix.includes("Seneste live koordinater")) {
                translatedAfter = t.latestCoordinates;
              } else if (afterPrefix.includes("Latest live coordinates")) {
                translatedAfter = t.latestCoordinates;
              }
              // Extract coordinates if present
              const coordsMatch = currentText.match(
                /\(Lat: (.+?), Lon: (.+?)\)/
              );
              if (coordsMatch) {
                translated = `${t.liveUpdate}${translatedAfter} (Lat: ${coordsMatch[1]}, Lon: ${coordsMatch[2]}).`;
              } else {
                translated = t.liveUpdate + translatedAfter;
              }
            }
            locationStatusEl.textContent = translated;
          }
        }

        // Update location label
        const locationLabelEl = document.getElementById("location-label");
        if (locationLabelEl) {
          const currentText = locationLabelEl.textContent;
          if (currentText) {
            let translated = currentText;
            if (
              currentText.includes("En route to") ||
              currentText.includes("P√• vej til")
            ) {
              const match = currentText.match(
                /(?:En route to|P√• vej til) (.+)/
              );
              if (match) {
                translated = t.enRouteTo(match[1]);
              }
            } else if (
              currentText.includes("Sailing the open ocean") ||
              currentText.includes("Sejler p√• det √•bne hav")
            ) {
              translated = t.sailingOcean;
            } else if (
              currentText.includes("Docked at") ||
              currentText.includes("Fort√∏jet ved")
            ) {
              const match = currentText.match(
                /(?:Docked at|Fort√∏jet ved) (.+)/
              );
              if (match) {
                translated = t.dockedAt(match[1]);
              }
            }
            locationLabelEl.textContent = translated;
          }
        }

        // Update tomorrow status
        const tomorrowStatusEl = document.getElementById("tomorrow-status");
        if (tomorrowStatusEl) {
          const currentText = tomorrowStatusEl.textContent;
          if (
            currentText.includes("Loading") ||
            currentText.includes("Indl√¶ser")
          ) {
            tomorrowStatusEl.textContent = t.tomorrowLoading;
          } else if (
            currentText.startsWith("Tomorrow: ") ||
            currentText.startsWith("I morgen: ")
          ) {
            const afterPrefix = currentText.replace(
              /^(Tomorrow|I morgen):\s*/,
              ""
            );
            if (
              afterPrefix.includes("At sea between") ||
              afterPrefix.includes("Til s√∏s mellem")
            ) {
              const match = afterPrefix.match(
                /(?:At sea between|Til s√∏s mellem) (.+?) (?:and|og) (.+)/
              );
              if (match) {
                tomorrowStatusEl.textContent =
                  t.tomorrowPrefix + t.tomorrowAtSeaBetween(match[1], match[2]);
              }
            } else if (afterPrefix === "At sea" || afterPrefix === "Til s√∏s") {
              tomorrowStatusEl.textContent = t.tomorrowPrefix + t.tomorrowAtSea;
            } else if (
              afterPrefix.includes("Itinerary unavailable") ||
              afterPrefix.includes("Rejseplan utilg√¶ngelig")
            ) {
              tomorrowStatusEl.textContent =
                t.tomorrowPrefix + t.itineraryUnavailable;
            } else {
              tomorrowStatusEl.textContent = t.tomorrowPrefix + afterPrefix;
            }
          }
        }

        // Update map aria label
        const mapEl = document.getElementById("map");
        if (mapEl) {
          mapEl.setAttribute("aria-label", t.mapAriaLabel);
        }

        // Update time section
        updateTimeLabels();
        startLocalTimeClock();

        // Update weather title
        const weatherTitleEl = document.getElementById("weather-title");
        if (weatherTitleEl) {
          weatherTitleEl.textContent = t.weatherTitle;
        }

        // Update weather display if data exists
        updateWeatherDisplay();
      }

      languageToggle.addEventListener("click", () => {
        const newLang = currentLanguage === "en" ? "da" : "en";
        translatePage(newLang);
      });

      const countdownBanner = document.getElementById("countdown-banner");
      const mainShell = document.querySelector("main.shell");
      const birthdayShell = document.getElementById("birthday-shell");
      const christmasBanner = document.getElementById("christmas-banner");
      const urlParams = new URLSearchParams(window.location.search);
      const todayReference = new Date();
      const isBirthdayDate =
        todayReference.getFullYear() === 2025 &&
        todayReference.getMonth() === 10 &&
        todayReference.getDate() === 26;
      const forcedBirthday =
        urlParams.get("mode") === "birthday" ||
        urlParams.get("birthday") === "1";
      const isBirthday = isBirthdayDate || forcedBirthday;

      const isChristmasDate =
        todayReference.getFullYear() === 2025 &&
        todayReference.getMonth() === 11 &&
        todayReference.getDate() === 25;
      const forcedChristmas =
        urlParams.get("mode") === "xmas" ||
        urlParams.get("holiday") === "xmas" ||
        urlParams.get("xmas") === "1" ||
        urlParams.has("xmas");
      const isChristmas = isChristmasDate || forcedChristmas;

      if (isBirthday) {
        document.body.classList.add("birthday-mode");
        if (birthdayShell) birthdayShell.removeAttribute("hidden");
        if (countdownBanner) countdownBanner.style.display = "none";
        if (mainShell) mainShell.classList.add("birthday-visible");
        document.title = "Happy Birthday Kels!";
        if (forcedBirthday && !isBirthdayDate) {
          console.info(
            "[INIT] Birthday preview mode enabled via URL parameter."
          );
        }

        // Trigger confetti celebration
        function triggerConfetti() {
          if (typeof confetti === "undefined") {
            console.warn("[CONFETTI] Library not loaded yet");
            return;
          }
          const duration = 3000;
          const end = Date.now() + duration;
          const colors = [
            "#ff6b9d",
            "#c084fc",
            "#a78bfa",
            "#f472b6",
            "#ec4899",
            "#fbbf24",
            "#f59e0b",
          ];

          (function frame() {
            if (typeof confetti === "undefined") return;
            confetti({
              particleCount: 3,
              angle: 60,
              spread: 55,
              origin: { x: 0 },
              colors: colors,
            });
            confetti({
              particleCount: 3,
              angle: 120,
              spread: 55,
              origin: { x: 1 },
              colors: colors,
            });

            if (Date.now() < end) {
              requestAnimationFrame(frame);
            }
          })();
        }

        // Initial confetti burst
        setTimeout(() => {
          if (typeof confetti !== "undefined") {
            confetti({
              particleCount: 100,
              spread: 70,
              origin: { y: 0.6 },
              colors: [
                "#ff6b9d",
                "#c084fc",
                "#a78bfa",
                "#f472b6",
                "#ec4899",
                "#fbbf24",
                "#f59e0b",
              ],
            });
          }
        }, 500);

        // Continuous confetti from sides
        setTimeout(triggerConfetti, 1000);

        // Periodic bursts every 5 seconds
        setInterval(() => {
          if (typeof confetti !== "undefined") {
            confetti({
              particleCount: 50,
              spread: 60,
              origin: { y: 0.5 },
              colors: [
                "#ff6b9d",
                "#c084fc",
                "#a78bfa",
                "#f472b6",
                "#ec4899",
                "#fbbf24",
                "#f59e0b",
              ],
            });
          }
        }, 5000);
      }

      if (isChristmas) {
        document.body.classList.add("christmas-mode");
        if (christmasBanner) christmasBanner.removeAttribute("hidden");
        document.title = "Merry Christmas, Kels!";
        if (forcedChristmas && !isChristmasDate) {
          console.info(
            "[INIT] Christmas preview mode enabled via URL parameter."
          );
        }

        // Trigger confetti celebration
        function triggerChristmasConfetti() {
          if (typeof confetti === "undefined") {
            console.warn("[CONFETTI] Library not loaded yet");
            return;
          }
          const duration = 3000;
          const end = Date.now() + duration;
          const colors = [
            "#b91c1c",
            "#dc2626",
            "#ef4444",
            "#166534",
            "#15803d",
            "#22c55e",
          ];

          (function frame() {
            if (typeof confetti === "undefined") return;
            confetti({
              particleCount: 3,
              angle: 60,
              spread: 55,
              origin: { x: 0 },
              colors: colors,
            });
            confetti({
              particleCount: 3,
              angle: 120,
              spread: 55,
              origin: { x: 1 },
              colors: colors,
            });

            if (Date.now() < end) {
              requestAnimationFrame(frame);
            }
          })();
        }

        // Initial confetti burst
        setTimeout(() => {
          if (typeof confetti !== "undefined") {
            confetti({
              particleCount: 100,
              spread: 70,
              origin: { y: 0.6 },
              colors: [
                "#b91c1c",
                "#dc2626",
                "#ef4444",
                "#166534",
                "#15803d",
                "#22c55e",
              ],
            });
          }
        }, 500);

        // Continuous confetti from sides
        setTimeout(triggerChristmasConfetti, 1000);

        // Periodic bursts every 5 seconds
        setInterval(() => {
          if (typeof confetti !== "undefined") {
            confetti({
              particleCount: 50,
              spread: 60,
              origin: { y: 0.5 },
              colors: [
                "#b91c1c",
                "#dc2626",
                "#ef4444",
                "#166534",
                "#15803d",
                "#22c55e",
              ],
            });
          }
        }, 5000);
      }
      const targetDate = new Date("2026-05-15T00:00:00");
      const MS_PER_DAY = 1000 * 60 * 60 * 24;

      function updateCountdown() {
        const now = new Date();
        const today = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate()
        );
        const diff = targetDate - today;
        const daysRemaining = diff > 0 ? Math.ceil(diff / MS_PER_DAY) : 0;
        const t = translations[currentLanguage];
        countdownBanner.textContent = t.countdownDays(daysRemaining);
      }

      updateCountdown();
      if (!isBirthday) {
        setInterval(updateCountdown, 1000 * 60 * 60);
      }

      const staticItinerary = {
        "2025-10-19": "Piraeus (Athens), Greece",
        "2025-10-20": "Gythion (Sparta & Mystras), Greece",
        "2025-10-21": "Chania (Crete), Greece",
        "2025-10-22": "Mykonos, Greece",
        "2025-10-23": "Kusadasi (Ephesus), Turkey",
        "2025-10-24": "√áesme, Turkey",
        "2025-10-25": "At Sea",
        "2025-10-26": "Istanbul, Turkey",
        "2025-10-27": "Canakkale (Troy), Turkey",
        "2025-10-28": "Izmir, Turkey",
        "2025-10-29": "P√°tmos, Greece",
        "2025-10-30": "Rhodes, Greece",
        "2025-10-31": "At Sea",
        "2025-11-01": "Sp√©tsai, Greece",
        "2025-11-02": "Piraeus (Athens), Greece",
        "2025-11-03": "N√°fplio, Greece",
        "2025-11-04": "Katakolon (Olympia), Greece",
        "2025-11-05": "K√©rkira (Corfu), Greece",
        "2025-11-06": "Kotor, Montenegro",
        "2025-11-07": "Brindisi (Lecce), Italy",
        "2025-11-08": "At Sea",
        "2025-11-09": "Lipari",
        "2025-11-10": "Naples",
        "2025-11-11": "Civitavecchia (Rome), Italy",
        "2025-11-12": "Ajaccio",
        "2025-11-13": "Alghero",
        "2025-11-14": "Mah√≥n, Menorca",
        "2025-11-15": "Ibiza, Spain",
        "2025-11-16": "Cartagena, Spain",
        "2025-11-17": "Motril",
        "2025-11-18": "Ceuta",
        "2025-11-19": "Lisbon, Portugal",
        "2025-11-20": "At Sea",
        "2025-11-21": "At Sea",
        "2025-11-22": "At Sea",
        "2025-11-23": "At Sea",
        "2025-11-24": "At Sea",
        "2025-11-25": "At Sea",
        "2025-11-26": "At Sea",
        "2025-11-27": "At Sea",
        "2025-11-28": "Hamilton, Bermuda",
        "2025-11-29": "Hamilton, Bermuda",
        "2025-11-30": "At Sea",
        "2025-12-01": "At Sea",
        "2025-12-02": "Miami, FL",
        "2025-12-03": "At Sea",
        "2025-12-04": "At Sea",
        "2025-12-05": "At Sea",
        "2025-12-06": "Kralendijk, Bonaire",
        "2025-12-07": "Willemstad, Curacao",
        "2025-12-08": "At Sea",
        "2025-12-09": "Cartagena, Colombia",
        "2025-12-10": "At Sea",
        "2025-12-11": "Transit the Panama Canal",
        "2025-12-12": "Fuerte Amador (Panama City), Panama",
        "2025-12-13": "At Sea",
        "2025-12-14": "Puntarenas, Costa Rica",
        "2025-12-15": "At Sea",
        "2025-12-16": "Puerto Chiapas, Mexico",
        "2025-12-17": "At Sea",
        "2025-12-18": "At Sea",
        "2025-12-19": "Puerto Vallarta, Mexico",
        "2025-12-20": "At Sea",
        "2025-12-21": "At Sea",
        "2025-12-22": "At Sea",
        "2025-12-23": "At Sea",
        "2025-12-24": "At Sea",
        "2025-12-25": "At Sea",
        "2025-12-26": "At Sea",
        "2025-12-27": "At Sea",
        "2025-12-28": "Honolulu, HI",
        "2025-12-29": "Honolulu, HI",
        "2025-12-30": "Nawiliwili, Kauai, HI",
        "2025-12-31": "At Sea",
        "2026-01-01": "At Sea",
        "2026-01-02": "At Sea",
        "2026-01-03": "At Sea",
        "2026-01-04": "At Sea",
        "2026-01-05": "Cross the international date line",
        "2026-01-06": "At Sea",
        "2026-01-07": "At Sea",
        "2026-01-08": "At Sea",
        "2026-01-09": "At Sea",
        "2026-01-10": "Tokyo, Japan",
        "2026-01-11": "At Sea",
        "2026-01-12": "Osaka, Japan",
        "2026-01-13": "Kochi, Japan",
        "2026-01-14": "At Sea",
        "2026-01-15": "At Sea",
        "2026-01-16": "Keelung, Taiwan",
        "2026-01-17": "At Sea",
        "2026-01-18": "Hong Kong",
        "2026-01-19": "At Sea",
        "2026-01-20": "Halong Bay (Hanoi), Vietnam",
        "2026-01-21": "At Sea",
        "2026-01-22": "Da Nang (Hue), Vietnam",
        "2026-01-23": "At Sea",
        "2026-01-24": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-01-25": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-01-26": "At Sea",
        "2026-01-27": "Sihanoukville, Cambodia",
        "2026-01-28": "Ko Kood, Thailand",
        "2026-01-29": "Laem Chabang (Bangkok), Thailand",
        "2026-01-30": "At Sea",
        "2026-01-31": "At Sea",
        "2026-02-01": "Singapore",
        "2026-02-02": "At Sea",
        "2026-02-03": "At Sea",
        "2026-02-04": "Laem Chabang (Bangkok), Thailand",
        "2026-02-05": "Ko Kood, Thailand",
        "2026-02-06": "Sihanoukville, Cambodia",
        "2026-02-07": "At Sea",
        "2026-02-08": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-02-09": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-02-10": "At Sea",
        "2026-02-11": "Da Nang (Hue), Vietnam",
        "2026-02-12": "At Sea",
        "2026-02-13": "Halong Bay (Hanoi), Vietnam",
        "2026-02-14": "At Sea",
        "2026-02-15": "Hong Kong",
        "2026-02-16": "At Sea",
        "2026-02-17": "Halong Bay (Hanoi), Vietnam",
        "2026-02-18": "At Sea",
        "2026-02-19": "Da Nang (Hue), Vietnam",
        "2026-02-20": "At Sea",
        "2026-02-21": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-02-22": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-02-23": "At Sea",
        "2026-02-24": "Sihanoukville, Cambodia",
        "2026-02-25": "Ko Kood, Thailand",
        "2026-02-26": "Laem Chabang (Bangkok), Thailand",
        "2026-02-27": "At Sea",
        "2026-02-28": "At Sea",
        "2026-03-01": "Singapore",
        "2026-03-02": "At Sea",
        "2026-03-03": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-03-04": "Ho Chi Minh City (Saigon), Vietnam",
        "2026-03-05": "At Sea",
        "2026-03-06": "Da Nang (Hue), Vietnam",
        "2026-03-07": "At Sea",
        "2026-03-08": "Hong Kong",
        "2026-03-09": "Hong Kong",
        "2026-03-10": "At Sea",
        "2026-03-11": "Keelung, Taiwan",
        "2026-03-12": "At Sea",
        "2026-03-13": "At Sea",
        "2026-03-14": "Tokushima, Japan",
        "2026-03-15": "At Sea",
        "2026-03-16": "Tokyo, Japan",
        "2026-03-17": "At Sea",
        "2026-03-18": "Kobe, Japan",
        "2026-03-19": "At Sea",
        "2026-03-20": "Kagoshima, Japan",
        "2026-03-21": "Nagasaki, Japan",
        "2026-03-22": "Nagasaki, Japan",
        "2026-03-23": "Busan (Pusan), South Korea",
        "2026-03-24": "Shimonoeski, Japan",
        "2026-03-25": "Hiroshima, Japan",
        "2026-03-26": "Beppu, Japan",
        "2026-03-27": "Kochi, Japan",
        "2026-03-28": "At Sea",
        "2026-03-29": "Shimizu, Japan",
        "2026-03-30": "Yokohama, Japan",
      };

      const locationReference = {
        "Piraeus (Athens), Greece": {
          lat: 37.9391,
          lng: 23.6463,
          descriptor: "Docked in Piraeus, gateway to Athens.",
        },
        "Gythion (Sparta & Mystras), Greece": { lat: 36.7595, lng: 22.5631 },
        "Chania (Crete), Greece": { lat: 35.5138, lng: 24.0192 },
        "Mykonos, Greece": { lat: 37.4467, lng: 25.3289 },
        "Kusadasi (Ephesus), Turkey": { lat: 37.8618, lng: 27.2571 },
        "√áesme, Turkey": { lat: 38.3233, lng: 26.3025 },
        "At Sea": {
          descriptor: "Kels is currently sailing the open ocean.",
          zoom: 4,
        },
        "Istanbul, Turkey": { lat: 41.0082, lng: 28.9784 },
        "Canakkale (Troy), Turkey": { lat: 40.1553, lng: 26.4142 },
        "Izmir, Turkey": { lat: 38.4192, lng: 27.1287 },
        "P√°tmos, Greece": { lat: 37.3092, lng: 26.5469 },
        "Rhodes, Greece": { lat: 36.434, lng: 28.2176 },
        "Sp√©tsai, Greece": { lat: 37.2458, lng: 23.1595 },
        "N√°fplio, Greece": { lat: 37.567, lng: 22.8015 },
        "Katakolon (Olympia), Greece": { lat: 37.6459, lng: 21.3212 },
        "K√©rkira (Corfu), Greece": { lat: 39.6243, lng: 19.9217 },
        "Kotor, Montenegro": { lat: 42.4247, lng: 18.7712 },
        "Brindisi (Lecce), Italy": { lat: 40.6322, lng: 17.9417 },
        Lipari: { lat: 38.4723, lng: 14.9544 },
        Naples: { lat: 40.8518, lng: 14.2681 },
        "Civitavecchia (Rome), Italy": { lat: 42.0939, lng: 11.7969 },
        Ajaccio: { lat: 41.9192, lng: 8.7386 },
        Alghero: { lat: 40.557, lng: 8.3197 },
        "Mah√≥n, Menorca": { lat: 39.8889, lng: 4.265 },
        "Ibiza, Spain": { lat: 38.9067, lng: 1.4206 },
        "Cartagena, Spain": { lat: 37.6257, lng: -0.9966 },
        Motril: { lat: 36.7507, lng: -3.517 },
        Ceuta: { lat: 35.8894, lng: -5.3213 },
        "Lisbon, Portugal": { lat: 38.7223, lng: -9.1393 },
        "Hamilton, Bermuda": { lat: 32.2948, lng: -64.7814 },
        "Miami, FL": { lat: 25.7617, lng: -80.1918 },
        "Kralendijk, Bonaire": { lat: 12.1444, lng: -68.2655 },
        "Willemstad, Curacao": { lat: 12.1091, lng: -68.9317 },
        "Cartagena, Colombia": { lat: 10.391, lng: -75.4794 },
        "Transit the Panama Canal": {
          lat: 9.101,
          lng: -79.7,
          descriptor: "Transiting the Panama Canal.",
          zoom: 8,
        },
        "Fuerte Amador (Panama City), Panama": { lat: 8.9305, lng: -79.535 },
        "Puntarenas, Costa Rica": { lat: 9.9778, lng: -84.8333 },
        "Puerto Chiapas, Mexico": { lat: 14.69, lng: -92.421 },
        "Puerto Vallarta, Mexico": { lat: 20.6534, lng: -105.2253 },
        "Honolulu, HI": { lat: 21.3069, lng: -157.8583 },
        "Nawiliwili, Kauai, HI": { lat: 21.9586, lng: -159.3502 },
        "Cross the international date line": {
          lat: 15,
          lng: -179.5,
          descriptor: "Crossing the International Date Line.",
          zoom: 4,
        },
        "Tokyo, Japan": { lat: 35.6762, lng: 139.6503 },
        "Osaka, Japan": { lat: 34.6937, lng: 135.5023 },
        "Kochi, Japan": { lat: 33.5597, lng: 133.5311 },
        "Keelung, Taiwan": { lat: 25.1283, lng: 121.7417 },
        "Hong Kong": { lat: 22.3193, lng: 114.1694 },
        "Halong Bay (Hanoi), Vietnam": { lat: 20.9101, lng: 107.1839 },
        "Da Nang (Hue), Vietnam": { lat: 16.0544, lng: 108.2022 },
        "Ho Chi Minh City (Saigon), Vietnam": { lat: 10.8231, lng: 106.6297 },
        "Sihanoukville, Cambodia": { lat: 10.625, lng: 103.523 },
        "Ko Kood, Thailand": { lat: 11.658, lng: 102.543 },
        "Laem Chabang (Bangkok), Thailand": { lat: 13.0948, lng: 100.8838 },
        Singapore: { lat: 1.3521, lng: 103.8198 },
        "Tokushima, Japan": { lat: 34.0703, lng: 134.554 },
        "Kobe, Japan": { lat: 34.6901, lng: 135.1955 },
        "Kagoshima, Japan": { lat: 31.5966, lng: 130.5571 },
        "Nagasaki, Japan": { lat: 32.7503, lng: 129.8777 },
        "Busan (Pusan), South Korea": { lat: 35.1796, lng: 129.0756 },
        "Shimonoeski, Japan": { lat: 33.9578, lng: 130.9418 },
        "Hiroshima, Japan": { lat: 34.3853, lng: 132.4553 },
        "Beppu, Japan": { lat: 33.2846, lng: 131.4912 },
        "Shimizu, Japan": { lat: 35.015, lng: 138.4895 },
        "Yokohama, Japan": { lat: 35.4437, lng: 139.638 },
      };

      const itineraryEntries = Object.entries(staticItinerary)
        .map(([date, label]) => ({ date, label }))
        .sort((a, b) => a.date.localeCompare(b.date));

      const itineraryByDate = new Map(
        itineraryEntries.map((entry) => [entry.date, entry])
      );

      itineraryEntries.forEach((entry, index) => {
        entry.index = index;
      });

      const markerEmoji = isBirthday ? "üéÅ" : isChristmas ? "üéÑ" : null;
      const useImage = !isBirthday && !isChristmas;

      const map = L.map("map", {
        zoomControl: false,
        attributionControl: false,
      }).setView([0, 0], 2);

      L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
        {
          subdomains: "abcd",
          maxZoom: 19,
        }
      ).addTo(map);

      const markerIcon = L.divIcon({
        className: "kels-pin",
        iconSize: useImage ? [108, 108] : [48, 48],
        html: useImage
          ? `<div style="display:flex;align-items:center;justify-content:center;width:108px;height:108px;border-radius:50%;background:var(--accent-soft);backdrop-filter:blur(6px);box-shadow:0 14px 30px var(--pin-shadow);padding:9px;"><img src="cruise-ship.png" alt="Kels' ship" style="width:100%;height:100%;object-fit:contain;display:block;" /></div>`
          : `<div style="display:flex;align-items:center;justify-content:center;width:48px;height:48px;border-radius:50%;background:var(--accent-soft);backdrop-filter:blur(6px);box-shadow:0 14px 30px var(--pin-shadow);color:var(--accent);font-size:26px;line-height:1;">${markerEmoji}</div>`,
      });

      let marker = L.marker([0, 0], { icon: markerIcon }).addTo(map);
      marker.bindTooltip("Kels' ship", {
        direction: "top",
        offset: useImage ? [0, -41] : [0, -18],
      });

      const locationStatusEl = document.getElementById("location-status");
      const locationLabelEl = document.getElementById("location-label");
      const tomorrowStatusEl = document.getElementById("tomorrow-status");
      const shipStatusEl = document.getElementById("ship-status");

      function resolveStatusState(text) {
        if (!text) return "unknown";
        const normalized = text.toLowerCase();
        if (normalized.includes("sea") || normalized.includes("route")) {
          return "sea";
        }
        if (normalized.includes("dock") || normalized.includes("port")) {
          return "docked";
        }
        return "unknown";
      }

      function setShipStatus(text, state = resolveStatusState(text)) {
        shipStatusEl.textContent = text;
        shipStatusEl.dataset.state = state;
      }

      function getLocalISO(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      function hasCoords(info) {
        return info && Number.isFinite(info.lat) && Number.isFinite(info.lng);
      }

      function interpolateLng(start, end, t) {
        let diff = end - start;
        if (Math.abs(diff) > 180) {
          diff = diff > 0 ? diff - 360 : diff + 360;
        }
        let value = start + diff * t;
        if (value > 180) value -= 360;
        if (value < -180) value += 360;
        return value;
      }

      function findNeighborWithCoords(startIndex, direction) {
        let index = startIndex + direction;
        while (index >= 0 && index < itineraryEntries.length) {
          const candidate = itineraryEntries[index];
          const info = locationReference[candidate.label];
          if (hasCoords(info)) {
            return {
              entry: candidate,
              info,
              coords: { lat: info.lat, lng: info.lng },
            };
          }
          index += direction;
        }
        return null;
      }

      function deriveStatusFromLabel(label) {
        if (!label) {
          const t = translations[currentLanguage];
          return t.statusUnknown;
        }
        const normalized = label.toLowerCase();
        const t = translations[currentLanguage];
        if (
          normalized.includes("sea") ||
          normalized.includes("transit") ||
          normalized.includes("cross")
        ) {
          return t.statusAtSea;
        }
        return t.statusDocked;
      }

      function determineStatusFromEntry(entry) {
        const t = translations[currentLanguage];
        if (!entry) {
          return { label: t.statusUnknown, state: "unknown" };
        }
        const statusText = entry.status || deriveStatusFromLabel(entry.label);
        return { label: statusText, state: resolveStatusState(statusText) };
      }

      function buildEntryData(entry) {
        if (!entry) return null;
        const info = locationReference[entry.label] || {};
        let coords = hasCoords(info) ? { lat: info.lat, lng: info.lng } : null;
        let descriptor = info.descriptor;
        let displayLabel = info.displayLabel || entry.label;
        let previousPort = null;
        let nextPort = null;
        let status = deriveStatusFromLabel(entry.label);

        if (entry.label === "At Sea") {
          const t = translations[currentLanguage];
          displayLabel = t.tomorrowAtSea;
          const previous = findNeighborWithCoords(entry.index, -1);
          const next = findNeighborWithCoords(entry.index, 1);
          previousPort = previous ? previous.entry.label : null;
          nextPort = next ? next.entry.label : null;

          if (!descriptor) {
            if (previous && next) {
              descriptor = t.sailingBetween(
                previous.entry.label,
                next.entry.label
              );
            } else if (previous) {
              descriptor = t.sailingOnward(previous.entry.label);
            } else if (next) {
              descriptor = t.approaching(next.entry.label);
            } else {
              descriptor = t.currentlySailing;
            }
          }

          if (!coords) {
            if (previous && next) {
              const totalSpan = next.entry.index - previous.entry.index;
              const relative = entry.index - previous.entry.index;
              const ratio = totalSpan > 0 ? relative / totalSpan : 0;
              coords = {
                lat:
                  previous.coords.lat +
                  (next.coords.lat - previous.coords.lat) * ratio,
                lng: interpolateLng(
                  previous.coords.lng,
                  next.coords.lng,
                  ratio
                ),
              };
            } else if (previous) {
              coords = { ...previous.coords };
            } else if (next) {
              coords = { ...next.coords };
            }
          }
        } else if (!descriptor) {
          const t = translations[currentLanguage];
          descriptor = t.dockedNear(displayLabel);
        }

        const zoom =
          typeof info.zoom === "number"
            ? info.zoom
            : entry.label === "At Sea"
            ? 4
            : 6;

        return {
          date: entry.date,
          rawLabel: entry.label,
          label: displayLabel,
          descriptor,
          coords,
          zoom,
          previousPort,
          nextPort,
          status,
        };
      }

      function getEntryForDate(date) {
        const iso = getLocalISO(date);
        let entry = itineraryByDate.get(iso);
        if (!entry) {
          let index = itineraryEntries.findIndex((item) => item.date > iso);
          if (index === -1) {
            entry = itineraryEntries[itineraryEntries.length - 1];
          } else if (index === 0) {
            entry = itineraryEntries[0];
          } else {
            entry = itineraryEntries[index - 1];
          }
        }
        return buildEntryData(entry);
      }

      function buildStatusText(entry) {
        const t = translations[currentLanguage];
        if (!entry) {
          return t.couldNotDetermine;
        }
        if (entry.coords) {
          const latStr = entry.coords.lat.toFixed(4);
          const lngStr = entry.coords.lng.toFixed(4);
          return `${entry.descriptor} (Lat: ${latStr}, Lon: ${lngStr})`;
        }
        return entry.descriptor || t.trackingUpdate;
      }

      function persistLastKnown(entry) {
        if (!entry || !entry.coords) return;
        try {
          localStorage.setItem(
            "kels-last-coords",
            JSON.stringify({
              lat: entry.coords.lat,
              lng: entry.coords.lng,
              label: entry.label,
              descriptor: entry.descriptor,
              status: entry.status || shipStatusEl.textContent || null,
              storedAt: Date.now(),
            })
          );
          cacheTileForCoords(entry.coords, entry.zoom ?? 6);
        } catch (error) {
          console.warn("Unable to persist last known position", error);
        }
      }

      function readCachedLocation() {
        try {
          const cached = localStorage.getItem("kels-last-coords");
          if (cached) {
            const parsed = JSON.parse(cached);
            const lat = Number(parsed.lat);
            const lng = Number(parsed.lng);
            if (Number.isFinite(lat) && Number.isFinite(lng)) {
              return {
                lat,
                lng,
                label: parsed.label,
                descriptor: parsed.descriptor,
                status: parsed.status || null,
                storedAt: parsed.storedAt,
              };
            }
          }
        } catch (error) {
          console.warn("Failed to read cached coordinates", error);
        }
        return null;
      }

      function setMapToEntry(entry, { animate = false } = {}) {
        if (!entry || !entry.coords) return;
        const view = [entry.coords.lat, entry.coords.lng];
        const targetZoom = typeof entry.zoom === "number" ? entry.zoom : 6;
        marker.setLatLng(view);
        if (animate) {
          map.flyTo(view, targetZoom, { duration: 1.2 });
        } else {
          map.setView(view, targetZoom);
        }
      }

      function formatTomorrowStatus() {
        const t = translations[currentLanguage];
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        const entry = getEntryForDate(tomorrow);
        if (!entry) {
          return t.tomorrowPrefix + t.itineraryUnavailable;
        }
        if (entry.rawLabel === "At Sea") {
          if (entry.previousPort && entry.nextPort) {
            return (
              t.tomorrowPrefix +
              t.tomorrowAtSeaBetween(entry.previousPort, entry.nextPort)
            );
          }
          return t.tomorrowPrefix + t.tomorrowAtSea;
        }
        return t.tomorrowPrefix + entry.label;
      }

      async function fetchCoordinatesFromShipXplorer() {
        const proxyUrl =
          "https://r.jina.ai/https://www.shipxplorer.com/data/vessels/SEABOURN-ENCORE-IMO-9731171-MMSI-311000464";
        try {
          const response = await fetch(proxyUrl, {
            headers: {
              Accept: "text/plain",
            },
          });
          if (!response.ok) {
            console.warn("[SX] Response not OK:", response.status);
            return null;
          }

          const rawText = await response.text();

          // Find Latitude div - look for id="title" containing "Latitude" followed by id="value"
          let latValue = null;
          let lngValue = null;

          // Try to find latitude - search for "Latitude" title and get its value
          const latMatch = rawText.match(
            /<div[^>]*id\s*=\s*["']title["'][^>]*>Latitude<\/div>\s*<div[^>]*id\s*=\s*["']value["'][^>]*>([^<]+)<\/div>/is
          );
          if (latMatch) {
            latValue = parseFloat(latMatch[1].trim());
            console.log("[SX] Found Latitude:", latValue);
          }

          // Try to find longitude - search for "Longitude" title and get its value
          const lngMatch = rawText.match(
            /<div[^>]*id\s*=\s*["']title["'][^>]*>Longitude<\/div>\s*<div[^>]*id\s*=\s*["']value["'][^>]*>([^<]+)<\/div>/is
          );
          if (lngMatch) {
            lngValue = parseFloat(lngMatch[1].trim());
            console.log("[SX] Found Longitude:", lngValue);
          }

          if (Number.isFinite(latValue) && Number.isFinite(lngValue)) {
            console.log("[SX] ‚úÖ Coordinates extracted:", latValue, lngValue);
            return { lat: latValue, lng: lngValue };
          }

          return null;
        } catch (error) {
          console.warn("[SX] Error fetching from ShipXplorer:", error);
          return null;
        }
      }

      function getStatusFromItinerary(todayEntry) {
        if (!todayEntry) return null;

        const todayDate = new Date();
        const todayISO = getLocalISO(todayDate);
        const isAtSeaDay = todayEntry.rawLabel === "At Sea";

        // If it's an "At Sea" day, she's at sea
        if (isAtSeaDay) {
          // Find next port destination
          let nextPortEntry = null;
          for (let i = 0; i < itineraryEntries.length; i++) {
            const entry = itineraryEntries[i];
            if (entry.date > todayISO && entry.label !== "At Sea") {
              nextPortEntry = entry;
              break;
            }
          }

          return {
            isAtSea: true,
            destination: nextPortEntry
              ? nextPortEntry.label
              : todayEntry.nextPort || null,
            port: null,
            coords: todayEntry.coords,
          };
        }

        // It's a port day - check if she's docked (9am-6pm local time) or at sea
        const portInfo = locationReference[todayEntry.rawLabel];
        if (!portInfo || !hasCoords(portInfo)) {
          // No coordinates, can't determine timezone - assume at sea
          let nextPortEntry = null;
          for (let i = 0; i < itineraryEntries.length; i++) {
            const entry = itineraryEntries[i];
            if (entry.date > todayISO && entry.label !== "At Sea") {
              nextPortEntry = entry;
              break;
            }
          }
          return {
            isAtSea: true,
            destination: nextPortEntry ? nextPortEntry.label : null,
            port: null,
            coords: null,
          };
        }

        // Approximate timezone from longitude (rough approximation: 15 degrees = 1 hour)
        // This is a simple approximation - not perfect but should work for most cases
        const timezoneOffset = Math.round(portInfo.lng / 15);

        // Get UTC time
        const utcHours = todayDate.getUTCHours();
        const utcMinutes = todayDate.getUTCMinutes();
        const utcTimeMinutes = utcHours * 60 + utcMinutes;

        // Calculate local time
        const localTimeMinutes = utcTimeMinutes + timezoneOffset * 60;
        // Normalize to 0-1440 (minutes in a day)
        const normalizedMinutes = ((localTimeMinutes % 1440) + 1440) % 1440;
        const localHours = Math.floor(normalizedMinutes / 60);
        const localMinutes = normalizedMinutes % 60;

        // Check if between 9am (540 minutes) and 6pm (1080 minutes)
        const isDocked = normalizedMinutes >= 540 && normalizedMinutes < 1080;

        console.log("[ITINERARY] Port day:", todayEntry.rawLabel);
        console.log(
          "[ITINERARY] Local time:",
          localHours + ":" + String(localMinutes).padStart(2, "0")
        );
        console.log("[ITINERARY] Is docked (9am-6pm):", isDocked);

        if (isDocked) {
          return {
            isAtSea: false,
            destination: null,
            port: todayEntry.label,
            coords: todayEntry.coords,
          };
        } else {
          // Outside docked hours - she's at sea traveling to next destination
          let nextPortEntry = null;
          for (let i = 0; i < itineraryEntries.length; i++) {
            const entry = itineraryEntries[i];
            if (entry.date > todayISO && entry.label !== "At Sea") {
              nextPortEntry = entry;
              break;
            }
          }

          return {
            isAtSea: true,
            destination: nextPortEntry
              ? nextPortEntry.label
              : todayEntry.nextPort || null,
            port: null,
            coords: todayEntry.coords,
          };
        }
      }

      async function fetchCoordinatesFromCruiseMapper() {
        try {
          const response = await fetch(
            "https://r.jina.ai/https://www.cruisemapper.com/?imo=9731171",
            { headers: { Accept: "text/plain" } }
          );
          if (!response.ok) {
            console.warn("[CM] Response not OK:", response.status);
            return null;
          }

          const text = await response.text();

          // Look for pattern: "coordinates 37.92809 N / 16.3297 E"
          // Also handle variations like "coordinates 37.92809 N / 16.3297 E en route to Messina"
          const coordsMatch = text.match(
            /coordinates\s+([\d.]+)\s*([NS])\s*\/\s*([\d.]+)\s*([EW])/i
          );

          if (coordsMatch) {
            let lat = parseFloat(coordsMatch[1]);
            const latDir = coordsMatch[2].toUpperCase();
            let lng = parseFloat(coordsMatch[3]);
            const lngDir = coordsMatch[4].toUpperCase();

            // Apply direction (N/S, E/W)
            if (latDir === "S") lat = -lat;
            if (lngDir === "W") lng = -lng;

            if (Number.isFinite(lat) && Number.isFinite(lng)) {
              console.log("[CM] ‚úÖ Coordinates extracted:", lat, lng);
              return { lat, lng };
            }
          }

          return null;
        } catch (error) {
          console.warn("[CM] Error fetching from CruiseMapper:", error);
          return null;
        }
      }

      async function fetchLiveShipPosition() {
        // Fetch both in parallel for speed
        const [cruiseMapperData, shipXplorerCoords] = await Promise.all([
          // Get coordinates and destination from CruiseMapper IMO page
          (async () => {
            try {
              const response = await fetch(
                "https://r.jina.ai/https://www.cruisemapper.com/?imo=9731171",
                { headers: { Accept: "text/plain" } }
              );
              if (!response.ok) return null;
              const text = await response.text();

              const result = {
                coords: null,
                destination: null,
                isAtSea: false,
              };

              // Extract coordinates: "coordinates 37.92809 N / 16.3297 E"
              const coordsMatch = text.match(
                /coordinates\s+([\d.]+)\s*([NS])\s*\/\s*([\d.]+)\s*([EW])/i
              );

              if (coordsMatch) {
                let lat = parseFloat(coordsMatch[1]);
                const latDir = coordsMatch[2].toUpperCase();
                let lng = parseFloat(coordsMatch[3]);
                const lngDir = coordsMatch[4].toUpperCase();

                // Apply direction (N/S, E/W)
                if (latDir === "S") lat = -lat;
                if (lngDir === "W") lng = -lng;

                if (Number.isFinite(lat) && Number.isFinite(lng)) {
                  result.coords = { lat, lng };
                  console.log("[CM] ‚úÖ Coordinates extracted:", lat, lng);
                }
              }

              // Extract destination: "en route to Messina" (often appears after coordinates)
              const patterns = [
                // Pattern 1: More restrictive - proper capitalization
                /en route to\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*(?:\s+[A-Z][a-z]+)?)(?:\s*[.,;!?\n]|<|$)/,
                // Pattern 2: Less restrictive but still reasonable
                /en route to\s+([A-Za-z][a-z]+(?:\s+[A-Za-z][a-z]+)*)(?:\s*[.,;!?\n]|<|$)/i,
              ];

              let routeMatch = null;
              for (const pattern of patterns) {
                routeMatch = text.match(pattern);
                if (routeMatch) {
                  let destination = routeMatch[1].trim();

                  // Filter out HTML-like patterns
                  const looksLikeHtml =
                    /^[A-Z0-9\-_]+$/.test(destination) &&
                    destination.length > 8 &&
                    !/[a-z]/.test(destination);

                  const htmlArtifacts =
                    /^(MSRV|CLASS|ID|DATA|SRC|HREF|ALT|TITLE|STYLE|SCRIPT|RYBINSK|RYB|MSRV-RYB)/i;

                  const invalidPatterns = /^[0-9]+$|^[A-Z]{2,}-[A-Z]{2,}/;

                  if (
                    looksLikeHtml ||
                    htmlArtifacts.test(destination) ||
                    invalidPatterns.test(destination)
                  ) {
                    console.log(
                      "[CM] Filtered out invalid pattern:",
                      destination
                    );
                    routeMatch = null;
                    continue;
                  }

                  if (destination.length < 2 || destination.length > 50) {
                    console.log(
                      "[CM] Invalid destination length:",
                      destination
                    );
                    routeMatch = null;
                    continue;
                  }

                  break;
                }
              }

              if (routeMatch) {
                result.destination = routeMatch[1].trim();
                result.isAtSea = true;
                console.log(
                  "[CM] ‚úÖ 'en route' detected, destination:",
                  result.destination
                );
              }

              return result;
            } catch (error) {
              console.warn("[CM] CruiseMapper error:", error);
              return null;
            }
          })(),
          // Get coordinates from ShipXplorer as backup
          fetchCoordinatesFromShipXplorer(),
        ]);

        // Prioritize CruiseMapper coordinates, fallback to ShipXplorer
        const coords = cruiseMapperData?.coords || shipXplorerCoords;
        const isAtSea = cruiseMapperData?.isAtSea || false;
        const destination = cruiseMapperData?.destination || null;

        return {
          coords,
          destination,
          port: null,
          isAtSea,
          summary: "Live position update",
        };
      }

      async function updateLivePosition(todayEntry) {
        try {
          console.log(
            "[UPDATE] Starting updateLivePosition. todayEntry:",
            todayEntry?.label
          );
          const live = await fetchLiveShipPosition();

          // If scraping failed or returned invalid data, use itinerary as fallback
          let useItineraryFallback = false;
          if (!live || (!live.coords && !live.destination && !live.port)) {
            console.log(
              "[UPDATE] Scraping failed or returned no data, using itinerary fallback"
            );
            useItineraryFallback = true;
          } else if (live.destination) {
            // Check if destination looks like HTML artifacts
            const looksLikeHtml =
              /^[A-Z0-9\-_]+$/.test(live.destination) &&
              live.destination.length > 8 &&
              !/[a-z]/.test(live.destination);
            const htmlArtifacts =
              /^(MSRV|CLASS|ID|DATA|SRC|HREF|ALT|TITLE|STYLE|SCRIPT|RYBINSK|RYB|MSRV-RYB)/i;

            if (live.destination.length < 2 || live.destination.length > 50) {
              console.log(
                "[UPDATE] Invalid destination length from scraping, using itinerary fallback"
              );
              useItineraryFallback = true;
            } else if (looksLikeHtml || htmlArtifacts.test(live.destination)) {
              console.log(
                "[UPDATE] Destination looks like HTML artifact, using itinerary fallback:",
                live.destination
              );
              useItineraryFallback = true;
            }
          }

          // Use itinerary fallback if needed
          const itineraryStatus = getStatusFromItinerary(todayEntry);
          const finalLive =
            useItineraryFallback && itineraryStatus
              ? {
                  ...itineraryStatus,
                  summary: "Using itinerary schedule",
                }
              : live;

          if (!finalLive) {
            console.warn(
              "[UPDATE] No live data and no itinerary fallback available"
            );
            return;
          }

          console.log("[UPDATE] Live data received:", {
            isAtSea: finalLive.isAtSea,
            destination: finalLive.destination,
            port: finalLive.port,
            coords: finalLive.coords,
            usingFallback: useItineraryFallback,
          });

          const t = translations[currentLanguage];
          const statusLabel = finalLive.isAtSea
            ? t.statusAtSea
            : t.statusDocked;
          const statusState = finalLive.isAtSea ? "sea" : "docked";
          console.log("[UPDATE] Setting status:", statusLabel, statusState);
          setShipStatus(statusLabel, statusState);

          // If at sea, use itinerary to find the next port destination
          let labelText = t.cachedCoordinates;
          let itineraryDestination = null;

          if (finalLive.isAtSea) {
            // Find next port from itinerary (as fallback)
            if (todayEntry) {
              const todayDate = new Date();
              const todayISO = getLocalISO(todayDate);

              // Find the next entry that's not "At Sea" (must be AFTER today, not today)
              let nextPortEntry = null;
              for (let i = 0; i < itineraryEntries.length; i++) {
                const entry = itineraryEntries[i];
                // Only look at dates AFTER today (not >=, so we skip today)
                if (entry.date > todayISO && entry.label !== "At Sea") {
                  nextPortEntry = entry;
                  break;
                }
              }

              if (nextPortEntry) {
                itineraryDestination = nextPortEntry.label;
                console.log(
                  "[UPDATE] Found next port from itinerary:",
                  itineraryDestination
                );
              } else if (todayEntry.nextPort) {
                itineraryDestination = todayEntry.nextPort;
                console.log(
                  "[UPDATE] Using todayEntry.nextPort:",
                  itineraryDestination
                );
              }
            }

            // Prioritize scraped destination from CruiseMapper, fallback to itinerary
            if (finalLive.destination) {
              labelText = t.enRouteTo(finalLive.destination);
              console.log(
                "[UPDATE] Using destination:",
                finalLive.destination,
                useItineraryFallback
                  ? "(from itinerary)"
                  : "(from CruiseMapper)"
              );
            } else if (itineraryDestination) {
              labelText = t.enRouteTo(itineraryDestination);
              console.log(
                "[UPDATE] Using itinerary destination as fallback:",
                itineraryDestination
              );
            } else {
              labelText = t.sailingOcean;
            }
          } else if (finalLive.port) {
            labelText = t.dockedAt(finalLive.port);
          } else if (finalLive.destination) {
            labelText = finalLive.destination;
          }

          console.log("[UPDATE] Setting label text:", labelText);
          locationLabelEl.textContent = labelText;

          // Update status even if no coords
          if (finalLive.coords) {
            const latStr = finalLive.coords.lat.toFixed(4);
            const lngStr = finalLive.coords.lng.toFixed(4);
            let detail;
            if (finalLive.isAtSea) {
              // Prioritize scraped destination from CruiseMapper, fallback to itinerary
              if (finalLive.destination) {
                detail = t.currentlySailingEnRoute(finalLive.destination);
              } else if (itineraryDestination) {
                detail = t.currentlySailingEnRoute(itineraryDestination);
              } else if (todayEntry && todayEntry.nextPort) {
                detail = t.currentlySailingToward(todayEntry.nextPort);
              } else {
                detail = t.currentlySailing;
              }
            } else if (finalLive.port) {
              detail = t.currentlyAlongside(finalLive.port);
            } else {
              detail = t.latestCoordinates;
            }

            console.log("[UPDATE] Setting detail:", detail);
            locationStatusEl.textContent = `${t.liveUpdate}${detail} (Lat: ${latStr}, Lon: ${lngStr}).`;
            setMapToEntry(
              { coords: finalLive.coords, zoom: finalLive.isAtSea ? 6 : 8 },
              { animate: true }
            );
            persistLastKnown({
              coords: finalLive.coords,
              label: labelText,
              descriptor: locationStatusEl.textContent,
              status: statusLabel,
            });
            console.log(
              "[UPDATE] ‚úÖ Update complete. Status:",
              statusLabel,
              "Label:",
              labelText,
              useItineraryFallback ? "(using itinerary fallback)" : ""
            );
            // Update weather with new coordinates
            updateWeather(finalLive.coords);
          } else if (finalLive.isAtSea) {
            // We have "en route" status but no coordinates - still show the status
            let detail;
            // Prioritize scraped destination from CruiseMapper, fallback to itinerary
            if (finalLive.destination) {
              detail = t.currentlySailingEnRoute(finalLive.destination);
            } else if (itineraryDestination) {
              detail = t.currentlySailingEnRoute(itineraryDestination);
            } else if (todayEntry && todayEntry.nextPort) {
              detail = t.currentlySailingToward(todayEntry.nextPort);
            } else {
              detail = t.currentlySailing;
            }
            locationStatusEl.textContent = `${t.liveUpdate}${detail}`;
            console.log("[UPDATE] ‚úÖ Status updated (no coords):", statusLabel);
          } else if (finalLive.summary) {
            locationStatusEl.textContent = `${t.liveUpdate}${finalLive.summary}`;
            console.log("[UPDATE] Used summary instead of coords");
          } else if (useItineraryFallback && itineraryStatus) {
            // Fallback to itinerary status text
            if (itineraryStatus.isAtSea && itineraryStatus.destination) {
              locationStatusEl.textContent = `${
                t.liveUpdate
              }${t.currentlySailingEnRoute(itineraryStatus.destination)}`;
            } else if (!itineraryStatus.isAtSea && itineraryStatus.port) {
              locationStatusEl.textContent = `${
                t.liveUpdate
              }${t.currentlyAlongside(itineraryStatus.port)}`;
            } else {
              locationStatusEl.textContent = `${t.liveUpdate}${t.trackingUpdate}`;
            }
          }
        } catch (error) {
          console.error("[UPDATE] Error:", error);
          console.warn("Unable to fetch live ship data", error);
        }
      }

      // Weather data storage
      let currentWeatherData = null;
      let currentTimeZone = null;
      let currentUtcOffsetSeconds = null;
      let timeIntervalId = null;

      function formatUtcOffset(offsetSeconds) {
        if (!Number.isFinite(offsetSeconds)) return null;
        const hours = offsetSeconds / 3600;
        const rounded = Math.round(hours * 10) / 10;
        return `${hours >= 0 ? "+" : ""}${rounded}`;
      }

      function updateTimeLabels() {
        const t = translations[currentLanguage];
        const timeTitleEl = document.getElementById("time-title");
        const timeDescriptionEl = document.getElementById("time-description");

        if (timeTitleEl) {
          timeTitleEl.textContent = t.timeTitle;
        }

        if (timeDescriptionEl) {
          if (currentTimeZone) {
            timeDescriptionEl.textContent = t.timeSubtitle(currentTimeZone);
          } else if (currentUtcOffsetSeconds !== null) {
            timeDescriptionEl.textContent = t.timeSubtitleOffset(
              formatUtcOffset(currentUtcOffsetSeconds)
            );
          } else {
            timeDescriptionEl.textContent = t.timeLoading;
          }
        }
      }

      function startLocalTimeClock() {
        const clockEl = document.getElementById("time-clock");
        if (!clockEl) return;

        if (timeIntervalId) {
          clearInterval(timeIntervalId);
          timeIntervalId = null;
        }

        updateTimeLabels();

        if (!currentTimeZone && currentUtcOffsetSeconds === null) {
          clockEl.textContent = "--:--";
          return;
        }

        const render = () => {
          const now = new Date();
          let dateToFormat = now;
          const locale = currentLanguage === "da" ? "da-DK" : "en-US";
          const options = {
            hour: "2-digit",
            minute: "2-digit",
            hour12: currentLanguage === "en",
          };

          if (currentTimeZone) {
            options.timeZone = currentTimeZone;
          } else if (currentUtcOffsetSeconds !== null) {
            dateToFormat = new Date(now.getTime() + currentUtcOffsetSeconds * 1000);
          }

          clockEl.textContent = new Intl.DateTimeFormat(locale, options).format(
            dateToFormat
          );
        };

        render();
        timeIntervalId = setInterval(render, 30000);
      }

      function updateTimeSectionTimezone(timezone, offsetSeconds) {
        currentTimeZone = timezone || null;
        currentUtcOffsetSeconds = Number.isFinite(offsetSeconds)
          ? offsetSeconds
          : null;
        startLocalTimeClock();
      }

      // Convert Fahrenheit to Celsius
      function fahrenheitToCelsius(f) {
        return Math.round(((f - 32) * 5) / 9);
      }

      // Convert Celsius to Fahrenheit
      function celsiusToFahrenheit(c) {
        return Math.round((c * 9) / 5 + 32);
      }

      // Format temperature based on current language
      function formatTemperature(tempF) {
        if (currentLanguage === "da") {
          return fahrenheitToCelsius(tempF);
        }
        return Math.round(tempF);
      }

      // Get temperature unit based on current language
      function getTemperatureUnit() {
        return currentLanguage === "da" ? "¬∞C" : "¬∞F";
      }

      // Fetch weather data from Open-Meteo API (free, no API key required)
      async function fetchWeatherData(lat, lng) {
        if (!lat || !lng || !Number.isFinite(lat) || !Number.isFinite(lng)) {
          console.warn("[WEATHER] Invalid coordinates:", lat, lng);
          return null;
        }

        try {
          // Open-Meteo API - free, no API key required
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=temperature_2m,precipitation,weather_code,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weather_code&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto`;

          const response = await fetch(url);
          if (!response.ok) {
            console.warn("[WEATHER] Response not OK:", response.status);
            return null;
          }

          const data = await response.json();

          if (!data.current || !data.daily) {
            console.warn("[WEATHER] Invalid data structure");
            return null;
          }

          const weatherData = {
            current: data.current.temperature_2m,
            high: data.daily.temperature_2m_max[0],
            low: data.daily.temperature_2m_min[0],
            precipitation: data.current.precipitation,
            windSpeed: data.current.wind_speed_10m,
            weatherCode: data.current.weather_code,
            dailyPrecipitation: data.daily.precipitation_sum[0],
            dailyWeatherCode: data.daily.weather_code[0],
            timezone: data.timezone,
            utcOffsetSeconds: data.utc_offset_seconds,
          };

          console.log("[WEATHER] ‚úÖ Weather data fetched:", weatherData);
          return weatherData;
        } catch (error) {
          console.warn("[WEATHER] Error fetching weather:", error);
          return null;
        }
      }

      // Determine weather conditions from weather data
      function getWeatherConditions(weatherData) {
        if (!weatherData) return [];

        const conditions = [];
        const t = translations[currentLanguage];

        // Check for rain (precipitation > 0.01 inches or weather code indicates rain)
        const hasRain =
          (weatherData.precipitation > 0.01 ||
            weatherData.dailyPrecipitation > 0.01 ||
            (weatherData.weatherCode >= 51 && weatherData.weatherCode <= 67) ||
            (weatherData.dailyWeatherCode >= 51 &&
              weatherData.dailyWeatherCode <= 67)) &&
          weatherData.weatherCode !== 71 &&
          weatherData.weatherCode !== 73 &&
          weatherData.weatherCode !== 75 &&
          weatherData.dailyWeatherCode !== 71 &&
          weatherData.dailyWeatherCode !== 73 &&
          weatherData.dailyWeatherCode !== 75;

        // Check for snow (weather code 71, 73, 75, 77, 85, 86)
        const hasSnow =
          weatherData.weatherCode >= 71 && weatherData.weatherCode <= 86;

        // Check for wind (wind speed > 15 mph)
        const hasWind = weatherData.windSpeed > 15;

        if (hasRain) {
          conditions.push({ type: "rain", label: t.rain });
        }
        if (hasSnow) {
          conditions.push({ type: "snow", label: t.snow });
        }
        if (hasWind) {
          conditions.push({ type: "wind", label: t.wind });
        }

        return conditions;
      }

      // Update weather display
      function updateWeatherDisplay() {
        if (!currentWeatherData) return;

        const weatherCurrentEl = document.getElementById("weather-current");
        const weatherHighEl = document.getElementById("weather-high");
        const weatherLowEl = document.getElementById("weather-low");
        const weatherUnitEl = document.querySelector(".weather-unit");
        const weatherConditionsEl =
          document.getElementById("weather-conditions");
        const weatherLoadingEl = document.getElementById("weather-loading");

        if (weatherCurrentEl) {
          weatherCurrentEl.textContent = formatTemperature(
            currentWeatherData.current
          );
        }

        if (weatherHighEl) {
          const high = formatTemperature(currentWeatherData.high);
          weatherHighEl.textContent = `H: ${high}¬∞`;
        }

        if (weatherLowEl) {
          const low = formatTemperature(currentWeatherData.low);
          weatherLowEl.textContent = `L: ${low}¬∞`;
        }

        if (weatherUnitEl) {
          weatherUnitEl.textContent = getTemperatureUnit();
        }

        if (weatherConditionsEl && weatherLoadingEl) {
          const conditions = getWeatherConditions(currentWeatherData);
          weatherLoadingEl.style.display = "none";

          // Clear existing condition badges
          weatherConditionsEl.innerHTML = "";

          if (conditions.length > 0) {
            conditions.forEach((condition) => {
              const badge = document.createElement("span");
              badge.className = `weather-condition-badge ${condition.type}`;
              badge.textContent = condition.label;
              weatherConditionsEl.appendChild(badge);
            });
          } else {
            const t = translations[currentLanguage];
            const clearBadge = document.createElement("span");
            clearBadge.className = "weather-condition-badge";
            clearBadge.textContent = t.noConditions;
            weatherConditionsEl.appendChild(clearBadge);
          }
        }
      }

      function persistWeatherCache(coords, weatherData) {
        if (!coords || !weatherData) return;
        try {
          localStorage.setItem(
            "kels-weather-cache",
            JSON.stringify({ coords, weatherData, storedAt: Date.now() })
          );
        } catch (error) {
          console.warn("[WEATHER] Unable to cache weather", error);
        }
      }

      function readCachedWeather(coords) {
        try {
          const cached = localStorage.getItem("kels-weather-cache");
          if (!cached) return null;
          const parsed = JSON.parse(cached);
          if (!parsed.coords || !parsed.weatherData) return null;
          const latMatch = Math.abs(parsed.coords.lat - coords.lat) < 0.5;
          const lngMatch = Math.abs(parsed.coords.lng - coords.lng) < 0.5;
          if (latMatch && lngMatch) {
            return parsed.weatherData;
          }
        } catch (error) {
          console.warn("[WEATHER] Unable to read cached weather", error);
        }
        return null;
      }

      // Update weather when coordinates change
      async function updateWeather(coords) {
        if (!coords || !coords.lat || !coords.lng) {
          const weatherConditionsEl =
            document.getElementById("weather-conditions");
          const weatherLoadingEl = document.getElementById("weather-loading");
          if (weatherConditionsEl && weatherLoadingEl) {
            weatherLoadingEl.textContent =
              translations[currentLanguage].weatherError;
          }
          return;
        }

        const weatherLoadingEl = document.getElementById("weather-loading");
        if (weatherLoadingEl) {
          weatherLoadingEl.textContent =
            translations[currentLanguage].weatherLoading;
          weatherLoadingEl.style.display = "inline";
        }

        const weatherData = await fetchWeatherData(coords.lat, coords.lng);
        if (weatherData) {
          currentWeatherData = weatherData;
          persistWeatherCache(coords, weatherData);
          updateTimeSectionTimezone(
            weatherData.timezone,
            weatherData.utcOffsetSeconds
          );
          updateWeatherDisplay();
        } else {
          const cachedWeather = readCachedWeather(coords);
          const t = translations[currentLanguage];
          if (cachedWeather) {
            currentWeatherData = cachedWeather;
            updateWeatherDisplay();
            if (weatherLoadingEl) {
              weatherLoadingEl.textContent = `${t.showingCached} ${t.cachedCoordinates.toLowerCase()}`;
            }
          } else {
            if (weatherLoadingEl) {
              weatherLoadingEl.textContent = t.weatherError;
            }
          }
        }
      }

      function latLngToTile(lat, lng, zoom) {
        const latRad = (lat * Math.PI) / 180;
        const n = 2 ** zoom;
        const x = Math.floor(((lng + 180) / 360) * n);
        const y = Math.floor(
          ((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) /
            2) *
            n
        );
        return { x, y, z: zoom };
      }

      function buildTileUrl(tile, retina = false) {
        const r = retina ? "@2x" : "";
        return `https://a.basemaps.cartocdn.com/light_all/${tile.z}/${tile.x}/${tile.y}${r}.png`;
      }

      async function cacheTileForCoords(coords, zoom = 6) {
        if (!coords) return;
        try {
          const tileCoords = latLngToTile(coords.lat, coords.lng, zoom);
          const retina = window.devicePixelRatio > 1;
          const tileUrl = buildTileUrl(tileCoords, retina);
          const response = await fetch(tileUrl, { mode: "cors" });
          if (!response.ok) return;
          const blob = await response.blob();
          const reader = new FileReader();
          reader.onloadend = () => {
            try {
              localStorage.setItem(
                "kels-tile-cache",
                JSON.stringify({
                  dataUrl: reader.result,
                  tileCoords,
                  retina,
                  storedAt: Date.now(),
                })
              );
            } catch (error) {
              console.warn("[MAP] Unable to cache tile", error);
            }
          };
          reader.readAsDataURL(blob);
        } catch (error) {
          console.warn("[MAP] Failed to cache map tile", error);
        }
      }

      function readCachedTile() {
        try {
          const cached = localStorage.getItem("kels-tile-cache");
          if (!cached) return null;
          const parsed = JSON.parse(cached);
          if (parsed?.dataUrl && parsed?.tileCoords) {
            return parsed;
          }
        } catch (error) {
          console.warn("[MAP] Unable to read cached tile", error);
        }
        return null;
      }

      function applyCachedTileOverlay(cachedTile) {
        const container = map.getContainer();
        if (!container) return;
        if (cachedTile?.dataUrl) {
          container.style.backgroundImage = `url(${cachedTile.dataUrl})`;
          container.style.backgroundSize = "cover";
          container.style.backgroundPosition = "center";
        } else {
          container.style.backgroundImage = "";
        }
      }

      function init() {
        if (isBirthday) {
          console.log(
            "[INIT] Birthday mode active - displaying voyage data alongside the celebration."
          );
        } else {
          console.log("[INIT] Starting initialization...");
        }
        const todayEntry = getEntryForDate(new Date());
        const cached = readCachedLocation();
        const cachedTile = readCachedTile();

        console.log(
          "[INIT] todayEntry:",
          todayEntry?.label,
          todayEntry?.rawLabel
        );
        console.log("[INIT] cached:", cached?.label);

        const t = translations[currentLanguage];
        let statusText = t.couldNotDetermine;
        let labelText = t.statusUnknown;
        let statusInfo = { label: t.statusUnknown, state: "unknown" };

        if (todayEntry) {
          labelText = todayEntry.label;
          statusInfo = determineStatusFromEntry(todayEntry);
          console.log(
            "[INIT] Setting initial status from itinerary:",
            statusInfo
          );
          if (todayEntry.coords) {
            setMapToEntry(todayEntry, { animate: true });
            statusText = buildStatusText(todayEntry);
            persistLastKnown(todayEntry);
            updateWeather(todayEntry.coords);
            applyCachedTileOverlay(null);
          } else if (cached) {
            setMapToEntry({
              coords: { lat: cached.lat, lng: cached.lng },
              zoom: todayEntry.zoom,
            });
            statusText = `${
              todayEntry.descriptor || t.showingCached
            } (Lat: ${cached.lat.toFixed(4)}, Lon: ${cached.lng.toFixed(4)})`;
            if (cached.status) {
              statusInfo = {
                label: cached.status,
                state: resolveStatusState(cached.status),
              };
            }
            updateWeather({ lat: cached.lat, lng: cached.lng });
            applyCachedTileOverlay(cachedTile);
          } else {
            statusText = todayEntry.descriptor || statusText;
          }
        } else if (cached) {
          setMapToEntry({
            coords: { lat: cached.lat, lng: cached.lng },
            zoom: 5,
          });
          labelText = cached.label || t.cachedCoordinates;
          statusText = `${
            cached.descriptor || t.showingCached
          } (Lat: ${cached.lat.toFixed(4)}, Lon: ${cached.lng.toFixed(4)})`;
          if (cached.status) {
            statusInfo = {
              label: cached.status,
              state: resolveStatusState(cached.status),
            };
          }
          updateWeather({ lat: cached.lat, lng: cached.lng });
          applyCachedTileOverlay(cachedTile);
        }

        console.log(
          "[INIT] Setting initial display - Label:",
          labelText,
          "Status:",
          statusInfo.label
        );
        locationStatusEl.textContent = statusText;
        locationLabelEl.textContent = labelText;
        setShipStatus(statusInfo.label, statusInfo.state);
        tomorrowStatusEl.textContent = formatTomorrowStatus();

        console.log("[INIT] Calling updateLivePosition...");
        updateLivePosition(todayEntry);
      }

      init();
    </script>
  </body>
</html>
